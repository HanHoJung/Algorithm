# 알고리즘(기초)

[TOC]



## 수학

> ### 나머지 연산

컴퓨터의 수의 범위는 한정적이기 때문에 Big number를 표현할 수 없다. 때문에, 그 수가 큰 경우 나머지 연산을 통해 답을 출력하라는 문제가 등장한다.

ex)

정수 자료형(int=> 2<sup>31</sup> -1, long=> 2<sup>63</sup>-1≈10<sup>18</sup>)

- **(A + B)mod M = ((A mod M) + (B mod M)) mod M**

- **(A * B)mod M = ((A mod M) * (B mod M)) mod M**

- (A - B)mod M = ((A mod M) - (B mod M) + M) mod M

- 나누기의 경우에는 성립하지 않는다.(Modular Inverse 적용, 페르마의 소정리)

  ```
  (6/3) % 3 = 2 % 3 = 2
  (6%3 / 3%3)%3 = (0/0)%3
  성립하지 않음
  ```



> ### 최대 공약수(GCD)

두 정수 A,B가 존재할 때 A와 B의 공통된 약수 중 가장 큰 정수를 **최대 공약수**라고 정의한다.

- 최대 공약수가 1인 두 수를 서로소(Coprime)라 한다.

- 최대 공약수 문제는 기약분수 형태로 출력하라는 문제에서 쓰이는 경우가 많다.

- 예를 들어 18/24 라는 수가 존재할 때 두 수의 최대공약수 6으로 나누게 되면 3/4 기약분수 형태가 된다.

```
ex)

24의 약수:1, 2, 3, 4, 6, 8, 12, 24

18의 약수:1, 2, 3, 6, 9, 18

24와 18의 공약수:1, 2, 3,6

최대 공약수:6
```

최대 공약수 찾는 방법: 유클리스 호제법

A>B일때, A%B r이라고 정의하자

GCD(A,B)

GCD(B,r)

r이 0이면 B가 최대 공약수 이다.

시간복잡도:O(logn)



> ### 최소 공배수(LCM)

두 정수 A,B가 존재할 때 A, B의 공통된 배수 중에서 가장 작은 정수

LCM = A*B/GCD 를 통해 구할 수 있다.



> ### 소수 찾기

소수란, 약수가 **1**과 **자기 자신 밖에 없는 수** 를 의미한다.



**어떤 수 N 소수 판별** 시간복잡도 O(루트 N)

**1~N 사이의 수 소수 판별** 시간복잡도 O(루트 N루트N)



**소수 판별법**

- 첫 번째 방법

  2보다 크고 N-1보다 작거나 같은 자연수로 나누어 떨어지면 소수가 아니다.

  2보다 크고 N-1보다 작거나 같은 자연수로 나누어 떨어지지 않으면 소수이다.

  ```c++
  bool primeCheck(int n){
      if(n<2){
          return false;
      }
      
      for(int i=2; i<=n-1; i++){
          if(n%i==0)
              return false;
      }
      
      return true;
  }
  
  //시간 복잡도 O(N)
  ```

- 두 번째 방법

  2보다 크고 N/2보다 작거나 같은 수로 나누어 떨어지면 소수가 아니다.

  2보다 크고 N/2보다 작거나 같은 수로 나누어 떨어지지 않으면 소수 이다.

  **어떤 수 N이 소수가 아니라면**

  N= a * b(a>1,a와 b는 자연수, a가 작을 수록 b는 크다.)라고 가정하자

  **N=2일때**

  a가 가질 수 있는 최소값은 2 이다. 그 때, b가 가질 수 있는 값은 b/2 이다.



  **N=3일때**

  a가 3일때, 그 때 b가 가질 수 있는 값은 b/3 이다.

  a가 가장 작을때 b가 가장 큰 값이므로 b는 N/2를 넘지 않는다.

```C++
bool primeCheck(int n){
    if(n<2){
        return false;
    }
    
    for(int i=2; i<=n/2; i++){
        if(n%i==0)
            return false;
    }
    
    return true;
}

//시간 복잡도 O(N/2)
```



- 세 번째 방법

​       2보다 크고 루트 N보다 작거나 같은 수로 나누어 떨어지면 소수가 아니다.

​       2보다 크고 루트 N보다 작거나 같은 수로 나누어 떨어지지 않으면 소수 이다.

​      **어떤 수 N이 소수가 아니라면**

​       N= a * b(a>1,  a<=b,  a<=루트n, b>=루트n) 이라 가정하자

​       a * b <= 루트 n * 루트 n = n

​       ex)

​        24의 약수 1, 2, 3, 4, 6, 8, 12, 24

​         루트 24=>4.xxx

​         1,2,3,4 |  6, 8, 12, 24

​         4까지 검사하면 모든 조합이 완성됨으로 4까지만 검사하면 된다.

```c++
bool primeCheck(int n){
    if(n<2){
        return false;
    }
    
    for(int i=2; i*i<=n; i++){
        if(n%i==0)
            return false;
    }
    
    return true;
}

//시간 복잡도 O(루트n)
2<= i <= 루트 n
i^2 <= n

```



- 네번째 방법

  **에라토스테네스의 체**

​       1부터 N까지 범위 안에 들어있는 모든 소수를 찾는 방법 입니다.

​        시간복잡도 O(N*log<sup>logn</sup>)

                1. 2부터 N까지 모든 수를 써놓는다.
                2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
                3. 그 수는 소수이다.
                4. 이제 그 수의 배수를 모두 지운다.

(참고 예제)


​      https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4

1부터 100까지 수가 있을 때      

2, 3, 5, 7 소수에 대하여 1~4과정을 수행하면 11의 배수는 이미 지워져 있으므로 더 이상 수행할 필요가 없다.

```c++
#include <iostream>
using namespace std;
int primeNumber[100];
int cnt=0;
int n=100;
bool check[101];

for(int i=i; i<=n; i++){//루트 n까지(i<=루트n) 검사해도 되지만, 우리는 prime 수를
                        //primeNumber배열에 모두 저장하기 위해서
    if(check[i]==false){
        primeNumber[cnt++] = i;
        //이 부분이 loglogn 복잡도
        for(int j=i*i; j<=n; j=j+i){
            check[j]=true;
        }
        //
    }
}

for(int i=i; i<=n; i++){
    if(check[i]==false){
        primeNumber[cnt++] = i;
        for(int j=i*2; j<=n; j=j+i){  //i*i 할 경우 n이 100만 인 경우 int 범위 초과나기때문에
            check[j]=true;
        }
    }
}

```



## 브루트 포스 - N과 M

N과 M 문제는 재귀 함수를 연습해 볼 수 있는 좋은 문제입니다.

우선, 이 문제에서 풀이법은 두 가지로 나누어 볼 수 있습니다.

**첫째, 자리를 만들어 놓고 채우는 방법(O(N<sup>M</sup>)**

m개의 자리 수를 만들어 놓고 자리에 수를 채어 넣는 방법



**둘째, 1~N까지 수 중 M의 자리 까지 선택 할 건지 말 건지 결정하는 방법(O(2<sup>M</sup>)**

예를 들어, 1<=n<=3 , m이 2자리 수 라고 하였을 때

1(0,x) 2(0,x) 3(0,x) => 경우의 수는 2 * 2 * 2 = 8가지 경우수가 나오게 됩니다.